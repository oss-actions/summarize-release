"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.listOf = exports.boolean = exports.BOOLEAN_VALUES = exports.integer = exports.number = exports.string = exports.getInput = void 0;
const output_1 = require("./output");
function getInput(name, options) {
    var _a, _b;
    options !== null && options !== void 0 ? options : (options = {});
    (_a = options.type) !== null && _a !== void 0 ? _a : (options.type = string);
    (_b = options.optional) !== null && _b !== void 0 ? _b : (options.optional = false);
    const value = process.env[`INPUT_${name.replace(/ /g, "_").toUpperCase()}`] || undefined;
    (0, output_1.debug)("input %o = %o", name, value);
    (0, output_1.debug)("options = %o", options);
    if (value === undefined &&
        (options.optional !== true || options.defaultValue !== undefined)) {
        if (options.defaultValue !== undefined) {
            return options.defaultValue;
        }
        throw new Error(`Missing required input '${name}'`);
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    if (value === undefined || value === null)
        return undefined;
    try {
        return options.type(value);
    }
    catch (error) {
        throw new Error(`Unable to parse input '${name}'`);
    }
}
exports.getInput = getInput;
exports.default = getInput;
// types
function string(value) {
    return value;
}
exports.string = string;
function number(value) {
    const n = Number(value);
    if (Number.isNaN(n)) {
        throw new Error("Could not parse number");
    }
    return n;
}
exports.number = number;
function integer(value) {
    const n = parseInt(value);
    if (Number.isNaN(n)) {
        throw new Error("Could not parse integer");
    }
    return n;
}
exports.integer = integer;
exports.BOOLEAN_VALUES = {
    // truthy
    true: true,
    y: true,
    yes: true,
    on: true,
    enable: true,
    enabled: true,
    active: true,
    activated: true,
    // falsy
    false: false,
    n: false,
    no: false,
    off: false,
    disable: false,
    disabled: false,
    inactive: false,
};
function boolean(value) {
    if (typeof value === "string") {
        return exports.BOOLEAN_VALUES[value] === true;
    }
    const options = value;
    return (value) => {
        if (options.strict && !(value in exports.BOOLEAN_VALUES)) {
            throw new Error(`Invalid boolean value '${value}', possible values are ${Object.keys(exports.BOOLEAN_VALUES)
                .map((bool) => `'${bool}'`)
                .join(", ")}`);
        }
        return exports.BOOLEAN_VALUES[value] === true;
    };
}
exports.boolean = boolean;
function listOf(type, { separator = /[,\s]+/g } = {}) {
    return (value) => value.split(separator).map(type);
}
exports.listOf = listOf;
