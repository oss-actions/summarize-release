"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Cash = exports.RunningProcess = exports.AwaitableReadableStringStream = exports.FinishedProcess = exports.Batch = exports.PowerShell = exports.Bash = exports.Shell = void 0;
const node_path_1 = require("node:path");
const node_fs_1 = require("node:fs");
const node_os_1 = require("node:os");
const node_child_process_1 = require("node:child_process");
const Callable_1 = __importDefault(require("./util/Callable"));
const web_1 = require("node:stream/web");
const isUnix = (0, node_os_1.type)() !== "Windows_NT";
const os = (0, node_os_1.type)();
const arch = (0, node_os_1.arch)();
function whichSync(command) {
    const cwd = process.cwd();
    return (process.env.PATH || "")
        .split(/:+/g)
        .map((path) => (0, node_path_1.resolve)(cwd, path, command))
        .find((path) => {
        try {
            (0, node_fs_1.accessSync)(path, node_fs_1.constants.X_OK);
            return true;
        }
        catch (_a) {
            return false;
        }
    });
}
exports.Shell = {
    name: "sh",
    path: whichSync("sh") || whichSync("sh.exe"),
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    supports(_os, _arch) {
        return true;
    },
    available() {
        return this.path !== undefined;
    },
    buildExecCommand(script) {
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        return [this.path, "-c", script];
    },
};
exports.Bash = {
    name: "bash",
    path: whichSync("bash") || whichSync("bash.exe"),
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    supports(_os, _arch) {
        return true;
    },
    available() {
        return this.path !== undefined;
    },
    buildExecCommand(script) {
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        return [this.path, "-c", script];
    },
};
exports.PowerShell = {
    name: "powershell",
    path: whichSync("pwsh") ||
        whichSync("pwsh.exe") ||
        whichSync("powershell") ||
        whichSync("powershell.exe"),
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    supports(_os, _arch) {
        return true;
    },
    available() {
        return this.path !== undefined;
    },
    buildExecCommand(script) {
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        return [this.path, "-Command", script];
    },
};
exports.Batch = {
    name: "batch",
    path: whichSync("cmd.exe"),
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    supports(_os, _arch) {
        return !isUnix;
    },
    available() {
        return this.path !== undefined;
    },
    buildExecCommand(script) {
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        return [this.path, "/s", script];
    },
};
class FinishedProcess {
    constructor(shell, stdall, stderr, stdout, code) {
        this.shell = shell;
        this.stdall = stdall;
        this.stderr = stderr;
        this.stdout = stdout;
        this.code = code;
    }
}
exports.FinishedProcess = FinishedProcess;
class AwaitableReadableStringStream extends web_1.ReadableStream {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    constructor(shell, proc, streams, 
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    ...superArgs) {
        super(...superArgs);
        this.$shell = shell;
        this.$proc = proc;
        this.$streams = streams;
    }
    then(onfulfilled, onrejected) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
                let out = "";
                const dataListener = (chunk) => (out += chunk.toString("utf8"));
                const cleanup = () => {
                    for (const stream of this.$streams) {
                        stream.off("data", dataListener);
                    }
                };
                for (const stream of this.$streams) {
                    stream.on("data", dataListener);
                }
                this.$proc.on("exit", (code) => {
                    cleanup();
                    if (code === null) {
                        code = 0;
                    }
                    if (code > 0 && !this.$shell.ignoreExitCode) {
                        return reject(new Error("Shell exited with non-zero code!"));
                    }
                    resolve(out);
                });
            }).then(onfulfilled, onrejected);
        });
    }
}
exports.AwaitableReadableStringStream = AwaitableReadableStringStream;
function createReadableStreamOfNodeStream(shell, proc, ...streams) {
    let closes = 0;
    return streams.every((stream) => !!stream)
        ? new AwaitableReadableStringStream(shell, proc, streams, {
            start(controller) {
                const closeListener = () => {
                    closes++;
                    if (closes === streams.length) {
                        cleanup();
                        controller.close();
                    }
                };
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                const errorListener = (error) => (cleanup(), controller.error(error));
                const dataListener = (chunk) => controller.enqueue(chunk.toString("utf8"));
                const cleanup = () => {
                    for (const stream of streams) {
                        stream.off("close", closeListener);
                        stream.off("end", closeListener);
                        stream.off("error", errorListener);
                        stream.off("data", dataListener);
                    }
                };
                for (const stream of streams) {
                    stream.on("close", closeListener);
                    stream.on("end", closeListener);
                    stream.on("error", errorListener);
                    stream.on("data", dataListener);
                }
            },
        })
        : undefined;
}
function createInputStream(stdin) {
    return stdin
        ? new web_1.WritableStream({
            write(input) {
                return new Promise((resolve, reject) => {
                    stdin.write(Buffer.from(input, "utf8"), (err) => {
                        if (err)
                            return reject(err);
                        return resolve();
                    });
                });
            },
        })
        : undefined;
}
class RunningProcess {
    constructor(shell, proc) {
        var _a, _b;
        this.$stdout = "";
        this.$stderr = "";
        this.$stdall = "";
        this.$shell = shell;
        this.$proc = proc;
        this.stdout = createReadableStreamOfNodeStream(this.$shell, this.$proc, this.$proc.stdout);
        this.stderr = createReadableStreamOfNodeStream(this.$shell, this.$proc, this.$proc.stderr);
        this.stdall = createReadableStreamOfNodeStream(this.$shell, this.$proc, this.$proc.stdout, this.$proc.stderr);
        this.stdin = createInputStream(this.$proc.stdin);
        const stdall = (data) => ((this.$stdall += data), data);
        (_a = proc.stdout) === null || _a === void 0 ? void 0 : _a.on("data", (chunk) => (this.$stdout += stdall(chunk.toString("utf8"))));
        (_b = proc.stderr) === null || _b === void 0 ? void 0 : _b.on("data", (chunk) => (this.$stderr += stdall(chunk.toString("utf8"))));
    }
    write(input) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.stdin) {
                throw new Error("Process does not have input stream!");
            }
            const writer = this.stdin.getWriter();
            try {
                yield writer.ready;
                yield writer.write(input);
                writer.releaseLock();
            }
            catch (error) {
                writer.releaseLock();
            }
        });
    }
    then(onfulfilled, onrejected) {
        return new Promise((resolve, reject) => {
            this.$proc.on("exit", (code) => {
                if (code === null)
                    code = 0;
                if (code > 0 && !this.$shell.ignoreExitCode) {
                    return reject(new Error("Shell exited with non-zero code!"));
                }
                resolve(new FinishedProcess(this.$shell, this.$stdall, this.$stderr, this.$stdout, code));
            });
        }).then(onfulfilled, onrejected);
    }
}
exports.RunningProcess = RunningProcess;
class Cash extends Callable_1.default {
    constructor(commandline) {
        super((template, ...args) => this.exec(String.raw(template, ...args)));
        this.spawnOptions = {};
        this.ignoreExitCode = false;
        this.setShell(commandline);
    }
    setShell(shell) {
        if (!shell.supports(os, arch)) {
            throw new Error(`Shell '${shell.name}' is not supported for ${os} (${arch})`);
        }
        if (!shell.available()) {
            throw new Error(`Shell '${shell.name}' is not available.`);
        }
        this.$commandline = shell;
    }
    exec(script) {
        const cmd = this.$commandline.buildExecCommand(script);
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const proc = (0, node_child_process_1.spawn)(cmd.shift(), cmd, this.spawnOptions);
        return new RunningProcess(this, proc);
    }
}
exports.Cash = Cash;
exports.default = Cash;
